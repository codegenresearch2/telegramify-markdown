from typing import Iterable\\nfrom mistletoe import block_token, span_token\\nfrom mistletoe.markdown_renderer import MarkdownRenderer, LinkReferenceDefinition, Fragment\\nfrom telebot import formatting\\nfrom .customize import markdown_symbol\\n\\nclass TelegramMarkdownRenderer(MarkdownRenderer):\\n    def render_heading(self, token: block_token.Heading, max_line_length: int) -> Iterable[str]:\\n        line = ""\\n        if token.level == 1:\\n            line += markdown_symbol.head_level_1\\n        elif token.level == 2:\\n            line += markdown_symbol.head_level_2\\n        elif token.level == 3:\\n            line += markdown_symbol.head_level_3\\n        elif token.level == 4:\\n            line += markdown_symbol.head_level_4\\n        fs = super().span_to_lines(token.children, max_line_length=max_line_length)\\n        text = next(fs, "")\\n        if text:\\n            line += " " + text\\n        if token.closing_sequence:\\n            line += " " + token.closing_sequence\\n        return [formatting.mbold(line, escape=False)]\\n\\n    def render_fenced_code_block(self, token: block_token.BlockCode, max_line_length: int) -> Iterable[str]:\\n        indentation = " " * token.indentation\\n        yield indentation + token.delimiter + token.info_string\\n        yield from self.prefix_lines(token.content[:-1].split("\\n"), indentation)\\n        yield indentation + token.delimiter\\n\\n    def render_inline_code(self, token: span_token.InlineCode) -> Iterable[Fragment]:\\n        return self.embed_span(Fragment(token.delimiter + token.padding), token.children, Fragment(token.padding + token.delimiter))\\n\\n    def render_block_code(self, token: block_token.BlockCode, max_line_length: int) -> Iterable[str]:\\n        return [formatting.mcode(token.content, escape=False)]\\n\\n    def render_setext_heading(self, token: block_token.SetextHeading, max_line_length: int) -> Iterable[str]:\\n        yield from self.span_to_lines(token.children, max_line_length=max_line_length)\\n        yield formatting.escape_markdown("——" * 5)\\n\\n    def render_emphasis(self, token: span_token.Emphasis) -> Iterable[Fragment]:\\n        token.delimiter = "_"\\n        return super().render_emphasis(token)\\n\\n    def render_strong(self, token: span_token.Strong) -> Iterable[Fragment]:\\n        return self.embed_span(Fragment(token.delimiter * 1), token.children)\\n\\n    def render_strikethrough(self, token: span_token.Strikethrough) -> Iterable[Fragment]:\\n        return self.embed_span(Fragment("~"), token.children)\\n\\n    def render_list_item(self, token: block_token.ListItem, max_line_length: int) -> Iterable[str]:\\n        if str(token.leader).strip().endswith("."):\\n            token.leader = formatting.escape_markdown(token.leader) + " "\\n        else:\\n            token.leader = formatting.escape_markdown("⦁")\\n        return super().render_list_item(token, max_line_length)\\n\\n    def render_link_reference_definition(self, token: LinkReferenceDefinition) -> Iterable[Fragment]:\\n        yield from (\\n            Fragment(markdown_symbol.link + formatting.mlink(content=token.title if token.title else token.label, url=token.dest, escape=True))\\n        )\\n\\n    def render_image(self, token: span_token.Image) -> Iterable[Fragment]:\\n        yield Fragment(markdown_symbol.image)\\n        yield from self.render_link_or_image(token, token.src)\\n\\n    def render_link(self, token: span_token.Link) -> Iterable[Fragment]:\\n        return self.render_link_or_image(token, token.target)\\n\\n    def render_link_or_image(self, token: span_token.SpanToken, target: str) -> Iterable[Fragment]:\\n        title = next(self.span_to_lines(token.children, max_line_length=20), "")\\n        if token.dest_type == "uri" or token.dest_type == "angle_uri":\\n            yield Fragment(formatting.mlink(url=target, content=title, escape=True))\\n        elif token.dest_type == "full":\\n            yield from (\\n                Fragment(formatting.escape_markdown("[")),\\n                Fragment(token.label, wordwrap=True),\\n                Fragment(formatting.escape_markdown("]"))\\n            )\\n        elif token.dest_type == "collapsed":\\n            yield Fragment(formatting.escape_markdown("[]"))\\n        else:\\n            pass\\n\\n    def render_auto_link(self, token: span_token.AutoLink) -> Iterable[Fragment]:\\n        yield Fragment(formatting.escape_markdown("<") + token.children[0].content + formatting.escape_markdown(">"))\n\\n    def render_table(self, token: block_token.Table, max_line_length: int) -> Iterable[str]:\\n        fs = super().render_table(token, max_line_length)\\n        return [formatting.mcode("\\n".join(fs))]\\n