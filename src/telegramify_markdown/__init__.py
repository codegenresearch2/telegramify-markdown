from typing import Union\\nimport mistletoe\\nfrom mistletoe.block_token import BlockToken, ThematicBreak\\nfrom mistletoe.markdown_renderer import LinkReferenceDefinition\\nfrom mistletoe.span_token import SpanToken\\nfrom telebot import formatting\\nfrom .render import TelegramMarkdownRenderer\\n\\ndef markdownify(text: str):\\n    # '_', '*', '[', ']', '(', ')', '~', '`', '>', '#', '+', '-', '=', '|', '{', '}', '.', '!'\\n    # if text in ["_", "*", "[", "]", "(", ")", "~", "`", ">", "#", "+", "-", "=", "|", "{", "}", ".", "!"]\\n    #     return text\\n    return formatting.escape_markdown(text)\\n\\ndef _update_text(token: Union[SpanToken, BlockToken]):\\n    \"\"\"Update the text contents of a span token and its children.\\n    `InlineCode` tokens are left unchanged.\"\"\"\\n    if isinstance(token, ThematicBreak):\\n        token.line = formatting.escape_markdown("————————")\\n        pass\\n    elif isinstance(token, LinkReferenceDefinition):\\n        pass\\n    else:\\n        assert hasattr(token, 'content'), f"Token {token} has no content attribute"\\n        token.content = markdownify(token.content)\\n\\ndef _update_block(token: BlockToken):\\n    \"\"\"Update the text contents of paragraphs and headings within this block, and recursively within its children.\"\"\"\\n    if hasattr(token, 'children'):\\n        # 解包所有的子节点\\n        for child in token.children:\\n            _update_block(child)\\n    else:\\n        _update_text(token)\\n\\ndef convert(content: str):\\n    with TelegramMarkdownRenderer() as renderer:\\n        document = mistletoe.Document(content)\\n        _update_block(document)\\n        result = renderer.render(document)\\n    return result